#!/usr/bin/env python3
"""
Extended CVE Scanner Collection - Part 2
Additional vulnerability scanners for network devices and enterprise apps
"""

import requests
from typing import Tuple
from urllib.parse import urljoin
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


class NetworkDeviceScanner:
    """Base for network device vulnerability scanners"""
    
    def __init__(self, target: str, timeout: int = 10):
        self.target = target if target.startswith('http') else f"https://{target}"
        self.timeout = timeout
        self.session = requests.Session()


class CVE_2020_3187_Scanner(NetworkDeviceScanner):
    """Cisco ASA/FTD Directory Traversal"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['+CSCOE+/session_password.js', '+CSCOT+/translation-table']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if resp.status_code == 200 and len(resp.text) > 0:
                    return True, f"Cisco vulnerability detected at {path}"
            except:
                pass
        return False, "Not vulnerable"


class CVE_2020_3452_Scanner(NetworkDeviceScanner):
    """Cisco ASA Path Traversal"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/+CSCOT+/oem-customization?app=AnyConnect&type=../../../',
                 '/+CSCOT+/translation-table?type=mst&textdomain=/%2bCSCOE%2b/portal_inc.lua']
        for path in paths:
            try:
                url = self.target + path
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'VPN' in resp.text or resp.status_code == 200:
                    return True, "Cisco ASA path traversal vulnerability"
            except:
                pass
        return False, "Not vulnerable"


class CVE_2023_24044_Scanner(NetworkDeviceScanner):
    """Fortinet FortiOS Auth Bypass"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/api/v2/cmdb/firewall/address', '/logincheck']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'fortinet' in resp.text.lower() or 'fortigate' in resp.text.lower():
                    return True, "Fortinet device detected"
            except:
                pass
        return False, "Fortinet device not detected"


class CVE_2024_24919_Scanner(NetworkDeviceScanner):
    """Check Point VPN Gateway RCE"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/clients/MyCRL', '/sslvpn/Portal/Main']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'checkpoint' in resp.text.lower() or resp.status_code in [200, 302]:
                    return True, "Check Point VPN detected"
            except:
                pass
        return False, "Not vulnerable"


class CVE_2018_0296_Scanner(NetworkDeviceScanner):
    """Cisco ASA Denial of Service"""
    
    def scan(self) -> Tuple[bool, str]:
        try:
            resp = self.session.get(self.target, timeout=self.timeout, verify=False)
            server = resp.headers.get('Server', '')
            if 'cisco' in server.lower() or 'asa' in server.lower():
                return True, "Cisco ASA device detected"
        except:
            pass
        return False, "Not vulnerable"


class EnterpriseAppScanner:
    """Base for enterprise application scanners"""
    
    def __init__(self, target: str, timeout: int = 10):
        self.target = target if target.startswith('http') else f"https://{target}"
        self.timeout = timeout
        self.session = requests.Session()


class CVE_2021_20323_Scanner(EnterpriseAppScanner):
    """Keycloak Request URI Bypass"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/auth/admin/master/console/', '/auth/realms/master']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'keycloak' in resp.text.lower():
                    return True, "Keycloak instance detected"
            except:
                pass
        return False, "Keycloak not detected"


class CVE_2023_29489_Scanner(EnterpriseAppScanner):
    """cPanel Unauthenticated Command Injection"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/cpsess', '/cpanel', '/login/?login_only=1']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'cpanel' in resp.text.lower() or 'whm' in resp.text.lower():
                    return True, "cPanel instance detected"
            except:
                pass
        return False, "cPanel not detected"


class CVE_2019_9670_Scanner(EnterpriseAppScanner):
    """Zimbra XXE Injection"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/zimbra/', '/service/soap']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'zimbra' in resp.text.lower():
                    return True, "Zimbra instance detected"
            except:
                pass
        return False, "Zimbra not detected"


class CVE_2020_27838_Scanner(EnterpriseAppScanner):
    """Ghostscript Type Confusion RCE"""
    
    def scan(self) -> Tuple[bool, str]:
        # This would require file upload testing - simplified version
        try:
            resp = self.session.get(self.target, timeout=self.timeout, verify=False)
            if 'ghostscript' in resp.text.lower() or 'imagemagick' in resp.text.lower():
                return True, "Image processing service detected"
        except:
            pass
        return False, "Not applicable"


class CVE_2021_40438_Scanner(EnterpriseAppScanner):
    """Apache HTTP Server SSRF"""
    
    def scan(self) -> Tuple[bool, str]:
        try:
            resp = self.session.get(self.target, timeout=self.timeout, verify=False)
            server = resp.headers.get('Server', '')
            if 'apache' in server.lower():
                version = server.split('/')[1] if '/' in server else ''
                return True, f"Apache HTTP Server detected: {server}"
        except:
            pass
        return False, "Apache not detected"


class CVE_2021_24917_Scanner(EnterpriseAppScanner):
    """WordPress Wordfence WAF Bypass"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/wp-admin/', '/wp-login.php', '/wp-content/plugins/wordfence/']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'wordpress' in resp.text.lower() or 'wp-' in resp.text:
                    return True, f"WordPress detected at {path}"
            except:
                pass
        return False, "WordPress not detected"


__all__ = [
    'CVE_2020_3187_Scanner',
    'CVE_2020_3452_Scanner',
    'CVE_2023_24044_Scanner',
    'CVE_2024_24919_Scanner',
    'CVE_2018_0296_Scanner',
    'CVE_2021_20323_Scanner',
    'CVE_2023_29489_Scanner',
    'CVE_2019_9670_Scanner',
    'CVE_2020_27838_Scanner',
    'CVE_2021_40438_Scanner',
    'CVE_2021_24917_Scanner',
]
