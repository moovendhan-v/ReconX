#!/usr/bin/env python3
"""
Additional CVE Scanners - Part 3
Legacy and specialized vulnerability scanners
"""

import requests
from typing import Tuple
from urllib.parse import urljoin
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


class LegacyCVEScanner:
    """Scanner for older/legacy CVEs"""
    
    def __init__(self, target: str, timeout: int = 10):
        self.target = target if target.startswith('http') else f"https://{target}"
        self.timeout = timeout
        self.session = requests.Session()


class CVE_2017_7269_Scanner(LegacyCVEScanner):
    """IIS 6.0 WebDAV Buffer Overflow"""
    
    def scan(self) -> Tuple[bool, str]:
        try:
            resp = self.session.options(self.target, timeout=self.timeout, verify=False)
            server = resp.headers.get('Server', '')
            if 'IIS/6.0' in server:
                return True, "IIS 6.0 detected - potentially vulnerable"
        except:
            pass
        return False, "IIS 6.0 not detected"


class CVE_2015_1635_Scanner(LegacyCVEScanner):
    """IIS HTTP.sys RCE"""
    
    def scan(self) -> Tuple[bool, str]:
        try:
            resp = self.session.get(self.target, timeout=self.timeout, verify=False)
            server = resp.headers.get('Server', '')
            if 'IIS' in server:
                return True, f"IIS server detected: {server}"
        except:
            pass
        return False, "IIS not detected"


class CVE_2015_7297_Scanner(LegacyCVEScanner):
    """Joomla SQL Injection"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/administrator/', '/index.php/component/users/']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'joomla' in resp.text.lower() or 'administrator' in resp.text:
                    return True, "Joomla instance detected"
            except:
                pass
        return False, "Joomla not detected"


class CVE_2000_0114_Scanner(LegacyCVEScanner):
    """IIS 4.0/5.0 RDS Exploit"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/msadc/', '/scripts/', '/_vti_bin/']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if resp.status_code == 200:
                    return True, f"Legacy IIS path accessible: {path}"
            except:
                pass
        return False, "Legacy paths not accessible"


class CVE_2018_11784_Scanner(LegacyCVEScanner):
    """Apache Tomcat Open Redirect"""
    
    def scan(self) -> Tuple[bool, str]:
        try:
            resp = self.session.get(self.target, timeout=self.timeout, verify=False)
            server = resp.headers.get('Server', '')
            if 'tomcat' in server.lower() or 'Apache-Coyote' in server:
                return True, f"Apache Tomcat detected: {server}"
        except:
            pass
        return False, "Tomcat not detected"


class SpecializedScanner:
    """Scanners for specific vulnerabilities"""
    
    def __init__(self, target: str, timeout: int = 10):
        self.target = target if target.startswith('http') else f"https://{target}"
        self.timeout = timeout
        self.session = requests.Session()


class CVE_2022_0165_Scanner(SpecializedScanner):
    """GitLab CE/EE ExifTool RCE"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/users/sign_in', '/api/v4/version']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'gitlab' in resp.text.lower():
                    return True, "GitLab instance detected"
            except:
                pass
        return False, "GitLab not detected"


class CVE_2024_1208_Scanner(SpecializedScanner):
    """Grafana Authentication Bypass"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/login', '/api/health']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'grafana' in resp.text.lower():
                    return True, "Grafana instance detected"
            except:
                pass
        return False, "Grafana not detected"


class CVE_2023_46805_Scanner(SpecializedScanner):
    """Ivanti Connect Secure Auth Bypass"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/api/v1/totp/user-backup-code/', '/dana-na/auth/url_default/welcome.cgi']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'ivanti' in resp.text.lower() or resp.status_code in [200, 302]:
                    return True, "Ivanti Connect Secure detected"
            except:
                pass
        return False, "Ivanti not detected"


class CVE_2019_12616_Scanner(SpecializedScanner):
    """WordPress Simple Cart Shopping Path Traversal"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/wp-content/plugins/wp-simple-shopping-cart/']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if resp.status_code == 200:
                    return True, "WordPress Simple Cart plugin detected"
            except:
                pass
        return False, "Plugin not detected"


class CVE_2024_4956_Scanner(SpecializedScanner):
    """Sonatype Nexus RCE"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/service/rest/v1/status', '/#browse/browse']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'nexus' in resp.text.lower():
                    return True, "Sonatype Nexus detected"
            except:
                pass
        return False, "Nexus not detected"


class CVE_2020_35489_Scanner(SpecializedScanner):
    """WordPress Contact Form 7 File Upload"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/wp-content/plugins/contact-form-7/']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if resp.status_code == 200:
                    return True, "Contact Form 7 plugin detected"
            except:
                pass
        return False, "Plugin not detected"


class CVE_2023_4568_Scanner(SpecializedScanner):
    """WooCommerce Payments Plugin RCE"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/wp-content/plugins/woocommerce-payments/', '/wp-json/wc/v3/']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'woocommerce' in resp.text.lower() or resp.status_code == 200:
                    return True, "WooCommerce detected"
            except:
                pass
        return False, "WooCommerce not detected"


class CVE_2023_5089_Scanner(SpecializedScanner):
    """WordPress Royal Elementor Addons LFI"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/wp-content/plugins/royal-elementor-addons/']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if resp.status_code == 200:
                    return True, "Royal Elementor plugin detected"
            except:
                pass
        return False, "Plugin not detected"


# Export all
__all__ = [
    'CVE_2017_7269_Scanner', 'CVE_2015_1635_Scanner', 'CVE_2015_7297_Scanner',
    'CVE_2000_0114_Scanner', 'CVE_2018_11784_Scanner', 'CVE_2022_0165_Scanner',
    'CVE_2024_1208_Scanner', 'CVE_2023_46805_Scanner', 'CVE_2019_12616_Scanner',
    'CVE_2024_4956_Scanner', 'CVE_2020_35489_Scanner', 'CVE_2023_4568_Scanner',
    'CVE_2023_5089_Scanner',
]
