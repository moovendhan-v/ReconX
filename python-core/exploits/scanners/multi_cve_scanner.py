#!/usr/bin/env python3
"""
Multi-CVE Scanner Collection for ReconX
Lightweight vulnerability detection scripts
"""

import argparse
import sys
import requests
from pathlib import Path
from urllib.parse import urljoin
from typing import List, Dict, Tuple
from requests.packages.urllib3.exceptions import InsecureRequestWarning

sys.path.insert(0, str(Path(__file__).parent.parent))
from shared import Theme, Signature, BannerDisplay

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


class ScannerBase:
    """Base class for all vulnerability scanners"""
    
    def __init__(self, target: str, timeout: int = 10):
        self.target = target if target.startswith('http') else f"https://{target}"
        self.timeout = timeout
        self.session = requests.Session()
        
    def scan(self) -> Tuple[bool, str]:
        """Override in child classes"""
        raise NotImplementedError


class CVE_2021_42063_Scanner(ScannerBase):
    """SAP Knowledge Warehouse XSS Scanner"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/irj/portal', '/sap/bc/gui/sap/its/webgui']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'SAP' in resp.text and resp.status_code == 200:
                    return True, f"Potential SAP instance found at {path}"
            except:
                pass
        return False, "SAP instance not detected"


class CVE_2018_8033_Scanner(ScannerBase):
    """Apache OFBiz XXE Injection Scanner"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/webtools/control/main', '/catalog/control/main']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'OFBiz' in resp.text or 'Apache OFBiz' in resp.headers.get('Server', ''):
                    return True, f"Apache OFBiz detected at {path}"
            except:
                pass
        return False, "Apache OFBiz not detected"


class CVE_2023_27524_Scanner(ScannerBase):
    """Apache Superset Authentication Bypass Scanner"""
    
    def scan(self) -> Tuple[bool, str]:
        try:
            url = urljoin(self.target, '/api/v1/security/login')
            resp = self.session.get(url, timeout=self.timeout, verify=False)
            if resp.status_code in [200, 405] and 'superset' in resp.text.lower():
                return True, "Apache Superset instance detected"
        except:
            pass
        return False, "Apache Superset not detected"


class PHPInfoLeakScanner(ScannerBase):
    """PHP Info File Leak Scanner"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/phpinfo.php', '/info.php', '/test.php', '/php.php', '/i.php']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if 'PHP Version' in resp.text or 'phpinfo()' in resp.text:
                    return True, f"PHPInfo leak found at {path}"
            except:
                pass
        return False, "No PHPInfo leaks detected"


class ShellHistoryLeakScanner(ScannerBase):
    """Shell History File Leak Scanner"""
    
    def scan(self) -> Tuple[bool, str]:
        paths = ['/.bash_history', '/.zsh_history', '/.sh_history', '/.history']
        for path in paths:
            try:
                url = urljoin(self.target, path)
                resp = self.session.get(url, timeout=self.timeout, verify=False)
                if resp.status_code == 200 and len(resp.text) > 10:
                    return True, f"Shell history leak found at {path}"
            except:
                pass
        return False, "No shell history leaks detected"


class CRLFInjectionScanner(ScannerBase):
    """CRLF Injection Scanner"""
    
    def scan(self) -> Tuple[bool, str]:
        payloads = ['/%0D%0ASet-Cookie:test=true', '/%0ASet-Cookie:test=true']
        for payload in payloads:
            try:
                url = self.target + payload
                resp = self.session.get(url, timeout=self.timeout, verify=False, allow_redirects=False)
                if 'Set-Cookie' in resp.headers and 'test=true' in resp.headers.get('Set-Cookie', ''):
                    return True, "CRLF injection vulnerability detected"
            except:
                pass
        return False, "Not vulnerable to CRLF injection"


class OpenRedirectScanner(ScannerBase):
    """Open Redirect Scanner"""
    
    def scan(self) -> Tuple[bool, str]:
        params = ['?url=', '?redirect=', '?next=', '?return=', '?redir=']
        test_url = 'https://evil.com'
        for param in params:
            try:
                url = self.target + param + test_url
                resp = self.session.get(url, timeout=self.timeout, verify=False, allow_redirects=False)
                if resp.status_code in [301, 302, 307, 308]:
                    location = resp.headers.get('Location', '')
                    if test_url in location:
                        return True, f"Open redirect found with parameter {param}"
            except:
                pass
        return False, "No open redirect detected"


def run_scanner(scanner_name: str, target: str) -> Tuple[bool, str, str]:
    """Run a specific scanner"""
    scanners = {
        'CVE-2021-42063': CVE_2021_42063_Scanner,
        'CVE-2018-8033': CVE_2018_8033_Scanner,
        'CVE-2023-27524': CVE_2023_27524_Scanner,
        'phpinfo-files-leaks': PHPInfoLeakScanner,
        'shell-history-leaks': ShellHistoryLeakScanner,
        'crlfi': CRLFInjectionScanner,
        'Open redirect': OpenRedirectScanner,
    }
    
    if scanner_name not in scanners:
        return False, scanner_name, "Scanner not found"
    
    scanner = scanners[scanner_name](target)
    vulnerable, message = scanner.scan()
    return vulnerable, scanner_name, message


def main():
    sig = Signature(
        tool_name="ReconX Multi-CVE Scanner",
        version="1.0",
        exploit_name="VulnScanner"
    )
    
    display = BannerDisplay(sig)
    display.show_header("""
█▀▄▀█ █ █ █   ▀█▀ ▀ ▄▀▀ █ █ ██▀   ▄▀▀ ▄▀▄ █▄ █ █▄ █ ██▀ █▀▄
█ ▀ █ ▀▄█ █▄▄  █  █ ▄██ ▀▄▀ █▄▄   ▄██ █▀█ █ ▀█ █ ▀█ █▄▄ █▀▄
    """)
    
    parser = argparse.ArgumentParser(description="Multi-CVE Vulnerability Scanner")
    parser.add_argument('-t', '--target', required=True, help='Target URL')
    parser.add_argument('-s', '--scanner', help='Specific scanner to run')
    parser.add_argument('-a', '--all', action='store_true', help='Run all scanners')
    args = parser.parse_args()
    
    if args.all:
        print(f"\n{Theme.OKBLUE}[*] Running all scanners against {args.target}{Theme.ENDC}\n")
        for scanner_name in ['CVE-2021-42063', 'CVE-2018-8033', 'CVE-2023-27524', 
                            'phpinfo-files-leaks', 'shell-history-leaks', 'crlfi', 'Open redirect']:
            vuln, name, msg = run_scanner(scanner_name, args.target)
            status = f"{Theme.FAIL}[VULNERABLE]" if vuln else f"{Theme.OKGREEN}[NOT VULNERABLE]"
            print(f"{status} {name}: {msg}{Theme.ENDC}")
    elif args.scanner:
        vuln, name, msg = run_scanner(args.scanner, args.target)
        if vuln:
            print(f"\n{Theme.FAIL}[VULNERABLE] {msg}{Theme.ENDC}\n")
            sys.exit(1)
        else:
            print(f"\n{Theme.OKGREEN}[NOT VULNERABLE] {msg}{Theme.ENDC}\n")
            sys.exit(0)
    else:
        parser.print_help()
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n{Theme.WARNING}[!] Scan interrupted{Theme.ENDC}\n")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Theme.FAIL}[!] Error: {e}{Theme.ENDC}\n")
        sys.exit(1)
